"""
ESP8266/ESP32 Agent
Handles sketch creation and OTA uploads for ESP devices.
"""

import os
import json
import subprocess
import time
from typing import Dict, Any, Optional
import requests


class ESPAgent:
    """Agent for managing ESP8266 and ESP32 devices."""
    
    # Sketch templates
    TEMPLATES = {
        "blink": """
// ESP{device} Blink Example
// Generated by Gemini Workspace

void setup() {{
  pinMode({gpio}, OUTPUT);
  Serial.begin(115200);
  Serial.println("ESP{device} Blink Started");
}}

void loop() {{
  digitalWrite({gpio}, HIGH);
  Serial.println("LED ON");
  delay({delay_on});
  digitalWrite({gpio}, LOW);
  Serial.println("LED OFF");
  delay({delay_off});
}}
""",
        "wifi_connect": """
// ESP{device} WiFi Connection Example
// Generated by Gemini Workspace

#include <ESP8266WiFi.h>

const char* ssid = "{ssid}";
const char* password = "{password}";

void setup() {{
  Serial.begin(115200);
  delay(10);
  
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);
  
  WiFi.begin(ssid, password);
  
  while (WiFi.status() != WL_CONNECTED) {{
    delay(500);
    Serial.print(".");
  }}
  
  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}}

void loop() {{
  // Your code here
}}
""",
        "ota_basic": """
// ESP{device} OTA Update Example
// Generated by Gemini Workspace

#include <ESP8266WiFi.h>
#include <ESP8266mDNS.h>
#include <WiFiUdp.h>
#include <ArduinoOTA.h>

const char* ssid = "{ssid}";
const char* password = "{password}";
const char* hostname = "{hostname}";

void setup() {{
  Serial.begin(115200);
  Serial.println("Booting");
  
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  
  while (WiFi.waitForConnectResult() != WL_CONNECTED) {{
    Serial.println("Connection Failed! Rebooting...");
    delay(5000);
    ESP.restart();
  }}
  
  // Configure OTA
  ArduinoOTA.setHostname(hostname);
  
  ArduinoOTA.onStart([]() {{
    String type;
    if (ArduinoOTA.getCommand() == U_FLASH) {{
      type = "sketch";
    }} else {{ // U_SPIFFS
      type = "filesystem";
    }}
    Serial.println("Start updating " + type);
  }});
  
  ArduinoOTA.onEnd([]() {{
    Serial.println("\\nEnd");
  }});
  
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {{
    Serial.printf("Progress: %u%%\\r", (progress / (total / 100)));
  }});
  
  ArduinoOTA.onError([](ota_error_t error) {{
    Serial.printf("Error[%u]: ", error);
    if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
    else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
    else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
    else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
    else if (error == OTA_END_ERROR) Serial.println("End Failed");
  }});
  
  ArduinoOTA.begin();
  Serial.println("Ready");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
}}

void loop() {{
  ArduinoOTA.handle();
  
  // Your code here
  {user_code}
}}
""",
        "sensor_read": """
// ESP{device} Sensor Reading Example
// Generated by Gemini Workspace

void setup() {{
  Serial.begin(115200);
  pinMode({sensor_pin}, INPUT);
  Serial.println("ESP{device} Sensor Reading Started");
}}

void loop() {{
  int sensorValue = analogRead({sensor_pin});
  Serial.print("Sensor Value: ");
  Serial.println(sensorValue);
  delay({read_interval});
}}
"""
    }
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize ESP agent with configuration.
        
        Args:
            config: Configuration dict with device settings
        """
        self.config = config
        self.sketch_dir = config.get('sketch_directory', './sketches')
        os.makedirs(self.sketch_dir, exist_ok=True)
        
    def create_sketch(self, device: str, template: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create a sketch for ESP device.
        
        Args:
            device: Device type (esp8266 or esp32)
            template: Template name (blink, wifi_connect, ota_basic, sensor_read)
            parameters: Template parameters
            
        Returns:
            Dict with sketch file path and content
        """
        device_lower = device.lower()
        if device_lower not in ["esp8266", "esp32"]:
            return {"status": "error", "message": "Device must be esp8266 or esp32"}
        
        if template not in self.TEMPLATES:
            # Try to infer template from task description
            task = parameters.get("task", "").lower()
            if "blink" in task or "led" in task:
                template = "blink"
            elif "wifi" in task or "connect" in task:
                template = "wifi_connect"
            elif "ota" in task:
                template = "ota_basic"
            elif "sensor" in task:
                template = "sensor_read"
            else:
                template = "blink"  # Default
        
        # Set default parameters
        default_params = {
            "device": device_lower.replace("esp", ""),
            "gpio": parameters.get("gpio", 2),
            "delay_on": parameters.get("delay_on", 1000),
            "delay_off": parameters.get("delay_off", 1000),
            "ssid": parameters.get("ssid", "YOUR_SSID"),
            "password": parameters.get("password", "YOUR_PASSWORD"),
            "hostname": parameters.get("hostname", f"{device_lower}-device"),
            "sensor_pin": parameters.get("sensor_pin", "A0"),
            "read_interval": parameters.get("read_interval", 1000),
            "user_code": parameters.get("user_code", "// Add your code here")
        }
        
        # Merge parameters
        params = {**default_params, **parameters}
        
        # Generate sketch code
        sketch_code = self.TEMPLATES[template].format(**params)
        
        # Save to file
        sketch_name = parameters.get("name", f"{device_lower}_{template}_{int(time.time())}")
        sketch_path = os.path.join(self.sketch_dir, f"{sketch_name}.ino")
        
        try:
            with open(sketch_path, 'w') as f:
                f.write(sketch_code)
            
            return {
                "status": "success",
                "sketch_path": sketch_path,
                "sketch_name": sketch_name,
                "device": device,
                "template": template,
                "code": sketch_code
            }
        except Exception as e:
            return {
                "status": "error",
                "message": f"Failed to create sketch: {str(e)}"
            }
    
    def compile_sketch(self, sketch_path: str, device: str) -> Dict[str, Any]:
        """
        Compile a sketch using Arduino CLI.
        
        Args:
            sketch_path: Path to the .ino file
            device: Device type (esp8266 or esp32)
            
        Returns:
            Dict with compilation result
        """
        # Determine FQBN (Fully Qualified Board Name)
        if "esp8266" in device.lower():
            fqbn = "esp8266:esp8266:generic"
        else:  # esp32
            fqbn = "esp32:esp32:esp32"
        
        try:
            # Check if arduino-cli is available
            result = subprocess.run(
                ["arduino-cli", "version"],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode != 0:
                return {
                    "status": "error",
                    "message": "arduino-cli not found. Install from https://arduino.github.io/arduino-cli/"
                }
            
            # Compile the sketch
            compile_cmd = [
                "arduino-cli", "compile",
                "--fqbn", fqbn,
                sketch_path
            ]
            
            result = subprocess.run(
                compile_cmd,
                capture_output=True,
                text=True,
                timeout=120
            )
            
            return {
                "status": "success" if result.returncode == 0 else "error",
                "stdout": result.stdout,
                "stderr": result.stderr,
                "exit_code": result.returncode
            }
            
        except subprocess.TimeoutExpired:
            return {"status": "error", "message": "Compilation timeout"}
        except FileNotFoundError:
            return {"status": "error", "message": "arduino-cli not found"}
        except Exception as e:
            return {"status": "error", "message": str(e)}
    
    def upload_ota(self, sketch_path: str, device_ip: str, device: str, port: int = 8266) -> Dict[str, Any]:
        """
        Upload sketch to ESP device via OTA.
        
        Args:
            sketch_path: Path to compiled .bin file or .ino file
            device_ip: IP address of the ESP device
            device: Device type (esp8266 or esp32)
            port: OTA port (default 8266)
            
        Returns:
            Dict with upload result
        """
        try:
            # If .ino file provided, need to find the .bin file
            if sketch_path.endswith('.ino'):
                # Look for compiled binary
                bin_path = sketch_path.replace('.ino', '.bin')
                if not os.path.exists(bin_path):
                    # Try build directory
                    sketch_dir = os.path.dirname(sketch_path)
                    sketch_name = os.path.basename(sketch_path).replace('.ino', '')
                    bin_path = os.path.join(sketch_dir, 'build', f"{sketch_name}.bin")
                    
                if not os.path.exists(bin_path):
                    return {
                        "status": "error",
                        "message": "Compiled binary not found. Compile the sketch first."
                    }
            else:
                bin_path = sketch_path
            
            # Upload via OTA using espota.py or arduino-cli
            upload_cmd = [
                "arduino-cli", "upload",
                "-p", f"{device_ip}:{port}",
                "--fqbn", f"esp{'8266' if 'esp8266' in device.lower() else '32'}:esp{'8266' if 'esp8266' in device.lower() else '32'}:generic",
                os.path.dirname(bin_path)
            ]
            
            result = subprocess.run(
                upload_cmd,
                capture_output=True,
                text=True,
                timeout=120
            )
            
            return {
                "status": "success" if result.returncode == 0 else "error",
                "device_ip": device_ip,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "exit_code": result.returncode
            }
            
        except Exception as e:
            return {
                "status": "error",
                "message": f"OTA upload failed: {str(e)}"
            }
    
    def execute(self, action: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute an action for ESP devices.
        
        Args:
            action: Action to perform
            parameters: Parameters for the action
            
        Returns:
            Dict with result
        """
        if action == "create_sketch":
            device = parameters.get("device", "esp8266")
            template = parameters.get("template", "blink")
            return self.create_sketch(device, template, parameters)
        
        elif action == "compile_sketch":
            sketch_path = parameters.get("sketch_path", "")
            device = parameters.get("device", "esp8266")
            if not sketch_path:
                return {"status": "error", "message": "sketch_path required"}
            return self.compile_sketch(sketch_path, device)
        
        elif action == "upload_ota":
            sketch_path = parameters.get("sketch_path", "")
            device_ip = parameters.get("device_ip", "")
            device = parameters.get("device", "esp8266")
            
            if not sketch_path or not device_ip:
                return {"status": "error", "message": "sketch_path and device_ip required"}
            
            # First compile if needed
            if sketch_path.endswith('.ino'):
                compile_result = self.compile_sketch(sketch_path, device)
                if compile_result["status"] != "success":
                    return compile_result
            
            return self.upload_ota(sketch_path, device_ip, device)
        
        else:
            return {"status": "error", "message": f"Unknown action: {action}"}
